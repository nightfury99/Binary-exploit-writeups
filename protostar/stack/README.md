# Reversing and Exploiting Protostar Stack challenges

These exercises can be found at https://exploit-exercises.com/protostar/

For all the challenges i downloaded the binaries on a local box and tried to reverse them rather than looking at the source-code that is provided at the webpage.

I'll be using pwntools for the exploits, This is an awesome python exploitation library that can be found at https://github.com/Gallopsled/pwntools 
And i'll be radare2 for the reversing the binaries. Radare can be found at http://radare.org.


#Stack0

```c
						                                 .----------------------------------------------.
                                                          | [0x80483f4] ;[c]                             |
                                                          |   ;-- main:                                  |
                                                          | (fcn) sym.main 65                            |
                                                          |   sym.main ();                               |
                                                          | ; var int local_1ch @ esp+0x1c               |
                                                          | ; var int local_5ch @ esp+0x5c               |
                                                          | push ebp                                     |
                                                          | mov ebp, esp                                 |
                                                          | and esp, 0xfffffff0                          |
                                                          | sub esp, 0x60                                |
                                                          | mov dword [esp + local_5ch], 0               |
                                                          | lea eax, [esp + local_1ch]                   |
                                                          | mov dword [esp], eax                         |
                                                          | call sym.imp.gets ;[a]; char*gets(char *s);  |
                                                          | mov eax, dword [esp + local_5ch]             |
                                                          | test eax, eax                                |
                                                          | je 0x8048427 ;[b]                            |
                                                          `----------------------------------------------'
                                                                  f t
                          .---------------------------------------' '-------------------------.
                          |                                                                   |
                          |                                                                   |
                  .---------------------------------------------------------------.     .---------------------------------------------------.
                  |  0x8048419 ;[f]                                               |     |  0x8048427 ;[b]                                   |
                  | mov dword [esp], str.you_have_changed_the__modified__variable |     | mov dword [esp], str.Try_again_                   |
                  | call sym.imp.puts ;[d]; int puts(const char *s);              |     | call sym.imp.puts ;[d]; int puts(const char *s);  |
                  | jmp 0x8048433 ;[e]                                            |     `---------------------------------------------------'
                  `---------------------------------------------------------------'         v
                      v                                                                     |
                      '----------------------------------------------------.----------------'
                                                                           |
                                                                           |
                                                                       .--------------------.
                                                                       |  0x8048433 ;[e]    |
                                                                       | leave              |
                                                                       | ret                |
                                                                       `--------------------'
```

The program will first set up the stack with the usual function prolog of pushing ebp and aligning the stack etc.
It will then reserve 96 bytes on the stack by subtracting esp with hex 0x60.
We note that there are two local variables recognized by radare, one at esp+0x1c and one at esp+0x5c.

The program will then zero out a variable located on the stack at esp+0x1c. This is most likely equivalent to "int local_var = 0;" in C.
It then loads an effective address into eax which in this case is a pointer to the local variable. Then it moves the value from esp into eax for later comparison. 
It then moves the content of eax onto the top of the stack. 

The test instruction will then do a logical AND operation of the eax regiester. If the result of 0 AND 0 which is 0, meaning that the Zero-flag is set, the statement will be true and we jump to the "try again" branch.
If the result is anything but 0, the statement will we false and we will jump the the code block that completes the challenge.
